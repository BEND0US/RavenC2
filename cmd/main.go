package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"flag"
	"fmt"
	"math/big"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

type ServerConfig struct {
	ServerIP   string
	ListenPort string
	//ShellPort  string
	CertPath string
	KeyPath  string
}

// Struct for MTLS certificates
type MTLSCertBundle struct {
	CACert     []byte
	CAKey      []byte
	ServerCert []byte
	ServerKey  []byte
	ClientCert []byte
	ClientKey  []byte
}

type CertBundle struct {
	CACert     []byte
	CAKey      []byte
	ServerCert []byte
	ServerKey  []byte
	ClientCert []byte
	ClientKey  []byte
}

func main() {
	serverConfig := ServerConfig{}

	// Server Build Flags
	flag.StringVar(&serverConfig.ServerIP, "server-ip", "127.0.0.1", "Server IP")
	flag.StringVar(&serverConfig.ListenPort, "server-port", "443", "Server Port")
	//flag.StringVar(&serverConfig.ShellPort, "shell-port", "4443", "Reverse shell default port")
	flag.Parse()

	requiredDirs := []string{"./downloads", "./uploads", "./output"}
	for _, dir := range requiredDirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			fmt.Printf("Directory creation error: %v\n", err)
			os.Exit(1)
		}
	}

	// Check or create certificates
	certPath := serverConfig.CertPath
	keyPath := serverConfig.KeyPath

	if certPath == "" || keyPath == "" {
		// Create certificates directory
		certsDir := "certs"
		if err := os.MkdirAll(certsDir, 0755); err != nil {
			fmt.Printf("Certificate directory creation error: %v\n", err)
			os.Exit(1)
		}

		if certPath == "" {
			certPath = filepath.Join(certsDir, "server.crt")
		}
		if keyPath == "" {
			keyPath = filepath.Join(certsDir, "server.key")
		}

		// Check if certificates exist
		if !fileExists(certPath) || !fileExists(keyPath) {
			fmt.Println("Certificates not found, creating new certificates...")
			certBundle, err := generateCertificates()
			if err != nil {
				fmt.Printf("Certificate creation error: %v\n", err)
				os.Exit(1)
			}

			// Write certificates to files
			if err := os.WriteFile(certPath, certBundle.ServerCert, 0644); err != nil {
				fmt.Printf("Certificate write error: %v\n", err)
				os.Exit(1)
			}

			if err := os.WriteFile(keyPath, certBundle.ServerKey, 0600); err != nil {
				fmt.Printf("Key write error: %v\n", err)
				os.Exit(1)
			}

			fmt.Printf("Certificates created: %s, %s\n", certPath, keyPath)
		}
	}

	// Create MTLS certificates
	mtlsCerts, err := setupMTLS(serverConfig.ServerIP)
	if err != nil {
		fmt.Printf("MTLS certificate creation error: %v\n", err)
		os.Exit(1)
	}

	// Test MTLS certificates
	if err := testMTLSCertificates(mtlsCerts); err != nil {
		fmt.Printf("MTLS certificate test failed: %v\n", err)
		os.Exit(1)
	}

	// Create server config file
	if err := createServerConfig(serverConfig, certPath, keyPath, mtlsCerts); err != nil {
		fmt.Printf("Server config creation error: %v\n", err)
		os.Exit(1)
	}

	// Create client config file
	if err := createClientConfig(mtlsCerts, serverConfig); err != nil {
		fmt.Printf("Client config creation error: %v\n", err)
		os.Exit(1)
	}

	// Build server
	if err := buildServer(serverConfig); err != nil {
		fmt.Printf("Server build error: %v\n", err)
		os.Exit(1)
	}

	//fmt.Println("MTLS certificates created successfully and config files updated.")
}

// Create server config
func createServerConfig(config ServerConfig, certPath, keyPath string, mtlsCerts *MTLSCertBundle) error {
	// Read existing certificates
	var certData, keyData []byte
	var err error

	certData, err = os.ReadFile(certPath)
	if err != nil {
		return fmt.Errorf("certificate read error: %v", err)
	}

	keyData, err = os.ReadFile(keyPath)
	if err != nil {
		return fmt.Errorf("key read error: %v", err)
	}

	// Config file content
	configContent := fmt.Sprintf(`package config

// This file is automatically generated
var (
	// C2 certificates
	C2_CERT     = []byte(%#v)
	C2_KEY      = []byte(%#v)
	
	// MTLS certificates
	CA_CERT     = []byte(%#v)
	CA_KEY      = []byte(%#v)
	SERVER_CERT = []byte(%#v)
	SERVER_KEY  = []byte(%#v)
	
	// Other settings
	LISTEN_PORT = "%s"

)
`, string(certData), string(keyData),
		string(mtlsCerts.CACert), string(mtlsCerts.CAKey),
		string(mtlsCerts.ServerCert), string(mtlsCerts.ServerKey), config.ListenPort)

	// Create config directory
	configDir := filepath.Join("..", "server", "config")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("server config directory creation error: %v", err)
	}

	// Write config file
	configPath := filepath.Join(configDir, "config.go")
	return os.WriteFile(configPath, []byte(configContent), 0644)
}

func createClientConfig(mtlsCerts *MTLSCertBundle, config ServerConfig) error {
	// Config file content
	configContent := fmt.Sprintf(`package config

// This file is automatically generated
var (
	// MTLS certificates
	CA_CERT     = []byte(%#v)
	CLIENT_CERT = []byte(%#v)
	CLIENT_KEY  = []byte(%#v)
	
	// Other settings
	BUILD_ID = ""
	SERVER_IP   = "%s"
	SERVER_PORT = "%s"
	ANTITECH = %v
)
`, string(mtlsCerts.CACert), string(mtlsCerts.ClientCert), string(mtlsCerts.ClientKey), config.ServerIP, config.ListenPort, false)

	// Create config directory
	configDir := filepath.Join("..", "client", "config")
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("client config directory creation error: %v", err)
	}

	// Write config file
	configPath := filepath.Join(configDir, "config.go")
	return os.WriteFile(configPath, []byte(configContent), 0644)
}

// Build server
func buildServer(config ServerConfig) error {

	outputName := "server"

	// Detect operating system
	goos := runtime.GOOS
	if goos == "windows" && !strings.HasSuffix(outputName, ".exe") {
		outputName += ".exe"
	}

	fmt.Printf("Building server...\n")

	// Build command
	cmd := exec.Command("go", "build", "-o", "../cmd/"+outputName)
	cmd.Dir = "../server" // server directory
	cmd.Env = append(os.Environ(),
		fmt.Sprintf("GOOS=%s", goos),
		fmt.Sprintf("GOARCH=%s", runtime.GOARCH),
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Run build command
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("build error: %v", err)
	}

	fmt.Println("[+] Server built successfully.")

	return nil
}

// Generate certificates and keys
func generateCertificates() (*CertBundle, error) {
	// Create CA certificate
	ca := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		Subject: pkix.Name{
			Organization: []string{fmt.Sprintf("CA")},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0),
		IsCA:                  true,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		BasicConstraintsValid: true,
	}

	// Create CA RSA key
	caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil, err
	}

	caBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &caPrivKey.PublicKey, caPrivKey)
	if err != nil {
		return nil, err
	}

	// Create server certificate
	serverTemplate := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		Subject: pkix.Name{
			Organization: []string{fmt.Sprintf("server")},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0),
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		BasicConstraintsValid: true,
		IPAddresses:           []net.IP{net.ParseIP("127.0.0.1")},
		DNSNames:              []string{"localhost"},
	}

	// Create server RSA key
	serverPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil, err
	}

	// Sign server certificate
	serverCertBytes, err := x509.CreateCertificate(
		rand.Reader, serverTemplate, ca, &serverPrivKey.PublicKey, caPrivKey)
	if err != nil {
		return nil, err
	}

	// Create client certificate
	clientTemplate := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		Subject: pkix.Name{
			Organization: []string{fmt.Sprintf("client")},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0),
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		BasicConstraintsValid: true,
	}

	// Create client RSA key
	clientPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil, err
	}

	// Sign client certificate
	clientCertBytes, err := x509.CreateCertificate(
		rand.Reader, clientTemplate, ca, &clientPrivKey.PublicKey, caPrivKey)
	if err != nil {
		return nil, err
	}

	// Convert to PEM format
	caCertPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: caBytes})
	caKeyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(caPrivKey)})

	serverCertPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: serverCertBytes})
	serverKeyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(serverPrivKey)})

	clientCertPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: clientCertBytes})
	clientKeyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(clientPrivKey)})

	return &CertBundle{
		CACert:     caCertPEM,
		CAKey:      caKeyPEM,
		ServerCert: serverCertPEM,
		ServerKey:  serverKeyPEM,
		ClientCert: clientCertPEM,
		ClientKey:  clientKeyPEM,
	}, nil
}

// Create MTLS certificates
func setupMTLS(serverIP string) (*MTLSCertBundle, error) {
	fmt.Println("Creating MTLS certificates...")

	// Create CA certificate
	ca := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		Subject: pkix.Name{
			Organization: []string{"MTLS CA"},
			CommonName:   "MTLS Root CA",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0),
		IsCA:                  true,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		BasicConstraintsValid: true,
	}

	caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil, fmt.Errorf("CA private key creation error: %v", err)
	}

	caBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &caPrivKey.PublicKey, caPrivKey)
	if err != nil {
		return nil, fmt.Errorf("CA certificate creation error: %v", err)
	}

	caCertPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: caBytes})
	caKeyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(caPrivKey)})

	// Create server certificate
	serverCert, serverKey, err := generatePeerCert("server", ca, caPrivKey, serverIP)
	if err != nil {
		return nil, fmt.Errorf("server certificate creation error: %v", err)
	}

	// Create client certificate
	clientCert, clientKey, err := generatePeerCert("client", ca, caPrivKey, serverIP)
	if err != nil {
		return nil, fmt.Errorf("client certificate creation error: %v", err)
	}

	return &MTLSCertBundle{
		CACert:     caCertPEM,
		CAKey:      caKeyPEM,
		ServerCert: serverCert,
		ServerKey:  serverKey,
		ClientCert: clientCert,
		ClientKey:  clientKey,
	}, nil
}

// Create peer certificate (server or client)
func generatePeerCert(peerType string, ca *x509.Certificate, caKey *rsa.PrivateKey, serverIP string) ([]byte, []byte, error) {
	// Certificate template
	template := &x509.Certificate{
		SerialNumber: big.NewInt(time.Now().UnixNano()),
		Subject: pkix.Name{
			Organization: []string{"MTLS " + peerType},
			CommonName:   "MTLS " + peerType,
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(10, 0, 0),
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment,
		BasicConstraintsValid: true,
	}

	// Additional settings for server
	if peerType == "server" {
		template.IPAddresses = []net.IP{net.ParseIP(serverIP)}
		template.DNSNames = []string{serverIP}
	}

	// Create private key
	privKey, err := rsa.GenerateKey(rand.Reader, 4096)
	if err != nil {
		return nil, nil, fmt.Errorf("%s private key creation error: %v", peerType, err)
	}

	// Create certificate
	certBytes, err := x509.CreateCertificate(rand.Reader, template, ca, &privKey.PublicKey, caKey)
	if err != nil {
		return nil, nil, fmt.Errorf("%s certificate creation error: %v", peerType, err)
	}

	// Convert to PEM format
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privKey)})

	return certPEM, keyPEM, nil
}

// Test MTLS certificates
func testMTLSCertificates(mtlsCerts *MTLSCertBundle) error {
	fmt.Println("Testing MTLS certificates...")

	// Load CA certificate
	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(mtlsCerts.CACert) {
		return fmt.Errorf("CA certificate load error")
	}

	// Load server certificate
	serverCert, err := tls.X509KeyPair(mtlsCerts.ServerCert, mtlsCerts.ServerKey)
	if err != nil {
		return fmt.Errorf("server certificate load error: %v", err)
	}

	// Load client certificate
	clientCert, err := tls.X509KeyPair(mtlsCerts.ClientCert, mtlsCerts.ClientKey)
	if err != nil {
		return fmt.Errorf("client certificate load error: %v", err)
	}

	// Verify server certificate
	serverX509Cert, err := x509.ParseCertificate(serverCert.Certificate[0])
	if err != nil {
		return fmt.Errorf("server certificate parse error: %v", err)
	}

	// Verify client certificate
	clientX509Cert, err := x509.ParseCertificate(clientCert.Certificate[0])
	if err != nil {
		return fmt.Errorf("client certificate parse error: %v", err)
	}

	// Verify server certificate with CA
	verifyOpts := x509.VerifyOptions{
		Roots: caCertPool,
	}

	if _, err := serverX509Cert.Verify(verifyOpts); err != nil {
		return fmt.Errorf("server certificate verification error: %v", err)
	}

	// Verify client certificate with CA
	if _, err := clientX509Cert.Verify(verifyOpts); err != nil {
		return fmt.Errorf("client certificate verification error: %v", err)
	}

	// Test TLS configuration
	/*serverTLSConfig := &tls.Config{
		Certificates: []tls.Certificate{serverCert},
		ClientCAs:    caCertPool,
		ClientAuth:   tls.RequireAndVerifyClientCert,
		MinVersion:   tls.VersionTLS12,
	}

	clientTLSConfig := &tls.Config{
		Certificates: []tls.Certificate{clientCert},
		RootCAs:      caCertPool,
		ServerName:   "localhost", // This is very important!
	}*/

	// Print certificate information
	fmt.Printf("Server certificate: %s, validity: %s - %s\n",
		serverX509Cert.Subject,
		serverX509Cert.NotBefore.Format("2006-01-02"),
		serverX509Cert.NotAfter.Format("2006-01-02"))

	fmt.Printf("Client certificate: %s, validity: %s - %s\n",
		clientX509Cert.Subject,
		clientX509Cert.NotBefore.Format("2006-01-02"),
		clientX509Cert.NotAfter.Format("2006-01-02"))

	fmt.Println("[+] All certificates verified successfully.")
	return nil
}

// Check if file exists
func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
